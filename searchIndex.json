[
{
		"title": "HOME",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "ALGOHUB HOME\n\n[!tip] Najlepsze artykuły\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/algorytmy/kmp/\">KMP</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/algorytmy/quicksort/\">Quicksort</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/drzewo-przedzialowe/\">Drzewo Przedziałowe</a>\n\n[!todo] Warto zacząć od\n\n<a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">Tablica</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/techniki/rekurencja/\">Rekurencja</a>\n\nO stronie\nTo strona poświęcona skupianiu notatek i zadań z informatyki i algorytmiki. Zdarza się, że artykuły wybiegają poza materiał przerabiany na lekcjach.\n\n[!warning] Przyszłe Artykuły\n\nProgramowanie Dynamiczne\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/zadania/zadania/\">Zadania</a>\nSkromny zbiór zadań, do poćwiczenia różnych tematów. Na razie w wersji testowej.",
		"tags": [ "note","gardenEntry"]
},

{
		"title": "Algorytm Euklidesa",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/algorytm-euklidesa/",
		"content": "Cel\nZnajduje <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">Największy Wspólny Dzielnik</a> (GCD lub NWD) dwóch liczb.\nIdea działania\nDla dwóch liczb całkowitych dodatnich a i b zachodzi równość:\nNWD(a,b)=NWD(b,a(modb))Algorytm powtarzamy tak długo, aż reszta z dzielenia wyniesie 0. Wtedy ostatnia niezerowa reszta (lub liczba, przez którą dzieliliśmy w ostatnim kroku) jest szukanym NWD.\nStworzymy dodatkową zmienną tymczasową, i tak długo jak b nie będzie 0, będziemy powtarzać\nc=amodba=bb=cKiedy użyć?\nW przypadku tego algorytmu proste jest zauważenie potrzeby jego użycia, gdy taka jest obecna.\nImplementacja\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nint NWD(int &amp; a, int &amp; b) {\nint c;\nwhile(b != 0){\nc = a%b;\na = b;\nb = c;\n}\nreturn a;\n}\n\nZłożoność\nCzasowa: O(n)\nPamięciowa: O(log n)",
		"tags": ["include", "include", "note","informatyka","matematyka"]
},

{
		"title": "DFS",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/dfs/",
		"content": "Depth First Search\nTo metoda przejścia po <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">grafie</a>, która kompletnie przegląda jedną scieżkę, zanim cofa się do następnej.\nIdea\nGdybyśmy chcieli rozwiązać labirynt, to moglibyśmy iść daną ścieżką, tak długo aż nie trafimy na ścianę (ślepy zaułek), a potem się cofać do ostatniego rozwidlenia. Jeżeli labirynt ma rozwiązanie, a my nie zapętlamy się, to kiedyś znajdziemy wyjście. To jest właśnie DFS, ponieważ labirynt to swego rodzaju <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">graf</a>, gdzie rozwidlenia są wierzchołkami.\nImplementacja\nJeżeli nasz graf może mieć zapętlenia, to będziemy potrzebowali jakieś metody, aby zapisać gdzie już byliśmy. Jeżeli napotkamy wierzchołek który już odwiedziliśmy, to możemy go pominąć.\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/techniki/rekurencja/\">Rekurencyjna</a>\nDFS jest idealny do implementacji rekurencyjnej. Jeżeli mamy funkcję, która przegląda wszystkie wierzchołki zaczynając od danego u, to wystarczy że w niej zawołamy ją samą dla każdego sąsiada u.\nPrzykładowy kod\nvector&lt;bool&gt; visited(n, false);\nvector&lt;vector&lt;int&gt;&gt; adj (n); //Lista sąsiedztwa, do przechowania grafu\n\nvoid DFS(int node){\n\tfor(auto &amp; v: adj[node]){\n\t\tDFS(v); // wołamy tą funkcję dla każdego sąsiada\n\t}\n}\n\nOczywiście normalnie chcemy, aby nasza funkcja coś robiła (na przykład zwracała największa wartość) wtedy zmieniamy typ funkcji na potrzebny.",
		"tags": [ "note"]
},

{
		"title": "Dijkstra's algorithm",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/dijkstra-s-algorithm/",
		"content": "Cel\nZnaleźć najkrótszą drogę od źródła do każdego z wierzchołków na <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">grafie</a>.\nIdea\nJest to <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">Algorytm zachłanny</a>, na każdym kroku wybiera najbliższy dostępny punkt, mając nadzieję że doprowadzi go to do pola najkrótszą trasą.\nPotrzebujemy do niego jakiejś formy zapisu <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">grafu</a>. Najczęściej będzie to lista sąsiedztwa, która dla każdego wierzchołka zapisuje listę wszystkich, z którymi ma krawędź.\nUżycie <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">kolejki priorytetowej</a>\nKolejka priorytetowa zawsze wybiera węzeł o najmniejszym dystansie, co pozwala skupić się na najkrótszych trasach i pominąć te mniej efektywne. Wybierając w pierwszej kolejności punkt z minimalną odległością, algorytm zyskuje pewność, że optymalna droga do jego sąsiadów została już ustalona. Dzięki temu, jeśli dany węzeł trafi do kolejki ponownie, nie musi być już przetwarzany – jego najkrótsza możliwa ścieżka jest już znana.\nJeżeli z kolejki wyciągniemy wierzchołek, który już sprawdziliśmy, to możemy go pominąć.\nPlan działania\n\nTworzymy tablicę dystans i ustawiamy wartość wszystkich elementów na ∞. Źródło powinno mieć wartość 0.\nTworzymy <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">kolejkę priorytetową</a> i na początku wrzucamy do niej parę źół(0; źródło) kolejką będzie przetrzymywała pary ł(dystans,wierzchołek).\nWeź pierwszy element (u) z kolejki i dla każdego jego sąsiada (v): Jeżeli$$dystans[v] &gt; dystans[u] + waga$$ to$$dystans[v] = dystans[u] + waga$$ i dodaj nową parę do kolejki\nJeżeli d_z_kolejki &gt; dystans[u], to znaczy, że w międzyczasie znaleźliśmy już lepszą trasę do wierzchołka u i ten wpis w kolejce jest &quot;przeterminowany&quot;. Wtedy robimy continue.\nBierzemy nowe elementy, tak długo aż kolejka nie będzie pusta.\n\nKod\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\nconst long long INF = 1e18;\n\nstruct Edge {\nint to;\nint weight;\n};\n\nvoid dijkstra(int start, const vector&lt;vector&lt;Edge&gt;&gt;&amp; graph) {\nint n = graph.size();\n\nvector&lt;long long&gt; dist(n, INF);\ndist[start] = 0;\n\n// 2. Kolejka priorytetowa przechowująca pary {dystans, wierzchołek}\n// std::greater sprawia, że najmniejsze wartości są na górze (min-heap)\npriority_queue&lt;pair&lt;long long, int&gt;, vector&lt;pair&lt;long long, int&gt;&gt;, greater&lt;pair&lt;long long, int&gt;&gt;&gt; pq;\n\npq.push({0, start});\n\nwhile (!pq.empty()) {\nlong long d = pq.top().first;\nint u = pq.top().second;\npq.pop();\n\n// 4. Sprawdzenie, czy to &quot;stara&quot; wartość\nif (d &gt; dist[u]) continue;\n\nfor (const auto&amp; edge : graph[u]) {\nint v = edge.to;\nint weight = edge.weight;\n\nif (dist[v] &gt; dist[u] + weight) {\ndist[v] = dist[u] + weight;\npq.push({dist[v], v});\n}\n}\n}\n\ncout &lt;&lt; &quot;Najkrótsze dystanse od wierzchołka &quot; &lt;&lt; start &lt;&lt; &quot;:&quot; &lt;&lt; endl;\nfor (int i = 0; i &lt; n; i++) {\nif (dist[i] == INF) cout &lt;&lt; i &lt;&lt; &quot;: nieosiągalny&quot; &lt;&lt; endl;\nelse cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; dist[i] &lt;&lt; endl;\n}\n}\n\nint main() {\nint nodes = 5;\nvector&lt;vector&lt;Edge&gt;&gt; graph(nodes);\n\n// Przykładowy graf\ngraph[0].push_back({1, 4});\ngraph[0].push_back({2, 1});\ngraph[2].push_back({1, 2});\ngraph[1].push_back({3, 1});\ngraph[2].push_back({3, 5});\ngraph[3].push_back({4, 3});\n\ndijkstra(0, graph);\n\nreturn 0;\n}\n\nWersja z wieloma źródłami\nMożemy chcieć użyć więcej niż 1 źródła. Wtedy będziemy szukać najmniejszego dystansu od jakiegokolwiek z źródeł.\nWtedy dla każdego źródła ustawimy dystans[u]=0 i wszystkie źródła trafią początkowo do kolejki priorytetowej.",
		"tags": ["include", "include", "include", "note"]
},

{
		"title": "KMP",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/kmp/",
		"content": "To bardzo efektywny algorytm szukania fragmentów tekstu. Używa przedprocesowania fragmentu, aby mądrze obsługiwać niezgodności, przez co osiąga złożoność liniową.\nIdea\nJak można szukać tekstu w tekście? Wbrew pozorom jest to istotna funkcja, potrzebna w wielu dziedzinach informatyki (i nie tylko).\nW dalszych podpunktach będziemy odnosić się do fragmentu szukanego jako v i do tekstu w którym szukamy jako a\nAlgorytm naiwny\nMożemy iść po a i zaczynając od każdego indeksu i sprawdzać dla każdego miejsca sw v czy a[i+s]=v[s]. Jak możemy zauważyć jest to bardzo nieefektywne, ponieważ gdy natrafimy na niezgodność, to musimy się cofać do samego początku w v.\nKMP\nZaczniemy od stworzenia tablicy lps. Longest prefix suffix to najdłuższy fragment na początku danego tekstu, który występuje też na końcu. Warto dodać, że prefix i suffix nie powinny się na siebie nakładać.\nNa przykład dla fragmentu aabcdcdaab, najdłuższym takim jest aab.\nTeraz jeżeli weźmiemy pierwsze s znaków naszego v to możemy wpisać najdłuższy prefix-suffix do lps[s−1] (tak, że nie bierzemy pod uwagę fragmentu 0 znakowego).\nPrzykładowa konstrukcja lps\nWzorzec: &quot;aabaaac&quot;\n\nIndeks 0: &quot;a&quot; → Brak właściwego prefiksu/sufiksu → lps[0] = 0\nIndeks 1: &quot;aa&quot; → &quot;a&quot; jest zarówno prefiksem, jak i sufiksem → lps[1] = 1\nIndeks 2: &quot;aab&quot; → Żaden prefiks nie pasuje do sufiksu → lps[2] = 0\nIndeks 3: &quot;aaba&quot; → &quot;a&quot; jest prefiksem i sufiksem → lps[3] = 1\nIndeks 4: &quot;aabaa&quot; → &quot;aa&quot; jest prefiksem i sufiksem → lps[4] = 2\nIndeks 5: &quot;aabaaa&quot; → &quot;aa&quot; jest prefiksem i sufiksem (tutaj najdłuższym dopasowaniem jest &quot;aa&quot;) → lps[5] = 2\nIndeks 6: &quot;aabaaac&quot; → Brak dopasowania (mismatch), następuje reset → lps[6] = 0\n\nJak sprawnie obliczyć lps\nPonieważ tablica 1-elementowa nie ma poprawnych prefixów, które są suffixami, wpisujemy lps[0]=0. Tworzymy zmienną len, która przetrzymuje jak długi jest poprzedni prefix suffix.\nIdziemy przez v od indexu 1, i porównujemy z v[len]. Mamy 3 przypadki.\nPrzypadek 1: v[i]==v[len]\nTo oznacza, że nowy znak kontynuuje istniejące dopasowanie.\n\nZwiększamy lps o 1\nlps[i]=len\nidziemy do kolejnego indeksu\n\nPrzypadek 2: v[i]!=v[len] i len==0\nNie ma żadnego pasującego prefixu, więc nie możemy wrócić do poprzedniego spasowania.\n\nlps[i]=0\nidziemy do kolejnego indeksu\n\nPrzypadek 3: v[i]!=v[len] i len≠0\nNie możemy kontynuować istniejącego ciągu, jednak może istnieć krótszy ciąg, który zadziała. Ponieważ v[0...len−1] = v[i−len...i−1], to możemy wrócić do lps[len−1].\n\nlen=lps[len−1]\nnie zmieniamy i\n\nKod\nvector&lt;int&gt; computeLPSArray(string &amp;pattern) {\nint n = pattern.size();\nvector&lt;int&gt; lps(n, 0);\n\nint len = 0;\nint i = 1;\n\nwhile (i &lt; n) {\nif (pattern[i] == pattern[len]) {\nlen++;\nlps[i] = len;\ni++;\n} else {\nif (len != 0) {\n// wracamy do starego wzoru\nlen = lps[len - 1];\n} else {\nlps[i] = 0;\ni++;\n}\n}\n}\n\nreturn lps;\n}\n\nDlaczego LPS jest takie ważne?\nTablica LPS (Longest Prefix Suffix) pozwala nam uniknąć bezcelowego sprawdzania tych samych znaków po raz drugi. W algorytmie naiwnym, po wykryciu niezgodności, cofamy się do początku wzorca. W KMP, dzięki LPS, wiemy dokładnie, o ile pozycji możemy bezpiecznie przesunąć nasz wzorzec, nie tracąc przy tym szansy na znalezienie dopasowania.\nWykorzystujemy fakt, że jeśli doszło do niezgodności na pozycji j, to znaki we wzorcu od 0 do j−1 pasowały do tekstu. Tablica LPS mówi nam, jak duża część tego dopasowanego fragmentu jest jednocześnie swoim własnym początkiem. Dzięki temu „skaczemy” wzorcem do przodu, zamiast cofać się w tekście.\nDziałanie Algorytmu KMP\nMając przygotowaną tablicę LPS, możemy przystąpić do przeszukiwania tekstu a w poszukiwaniu wzorca v.\nPrzebieg wyszukiwania:\n\nUżywamy dwóch wskaźników: i dla tekstu a oraz j dla wzorca v.\nJeśli znaki a[i] oraz v[j] są zgodne, zwiększamy oba wskaźniki.\nJeśli j osiągnie długość wzorca, oznacza to znalezienie dopasowania. Wtedy j przeskakuje do wartości lps[j−1], aby szukać kolejnych wystąpień.\nW przypadku niezgodności (a[i]≠v[j]):\n\nJeśli j≠0, zmieniamy j na lps[j−1] (nie cofamy wskaźnika i!).\nJeśli j=0, po prostu zwiększamy i, przechodząc do kolejnego znaku w tekście\n\nZłożoność czasowa wyszukiwania wynosi O(n), gdzie n to długość tekstu a. Całkowita złożoność algorytmu (wraz z budową LPS) to O(n+m), co czyni go niezwykle wydajnym.\n\nvector&lt;int&gt; computeLPSArray(string &amp;pattern) {\nint n = pattern.size();\nvector&lt;int&gt; lps(n, 0);\n\nint len = 0;\nint i = 1;\n\nwhile (i &lt; n) {\nif (pattern[i] == pattern[len]) {\nlen++;\nlps[i] = len;\ni++;\n} else {\nif (len != 0) {\n// wracamy do starego wzoru\nlen = lps[len - 1];\n} else {\nlps[i] = 0;\ni++;\n}\n}\n}\n\nreturn lps;\n}\n\nvoid KMPSearch(string text, string pattern) {\nint n = text.size();\nint m = pattern.size();\n\n// Przygotowanie tablicy pomocniczej\nvector&lt;int&gt; lps = computeLPSArray(pattern);\n\nint i = 0; // wskaźnik dla tekstu (text)\nint j = 0; // wskaźnik dla wzorca (pattern)\n\nwhile (i &lt; n) {\nif (pattern[j] == text[i]) {\ni++;\nj++;\n}\n\nif (j == m) {\ncout &lt;&lt; &quot;Wzorzec znaleziony na indeksie: &quot; &lt;&lt; i - j &lt;&lt; endl;\n\n// Przygotowanie do szukania kolejnych wystąpień\nj = lps[j - 1];\n}\nelse if (i &lt; n &amp;&amp; pattern[j] != text[i]) {\nif (j != 0) {\n// Dzięki LPS nie cofamy się w tekście (i zostaje w miejscu)\nj = lps[j - 1];\n} else {\n// Jeśli j jest na początku, po prostu przesuwamy się w tekście\ni++;\n}\n}\n}\n}",
		"tags": [ "note"]
},

{
		"title": "Merge Sort",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/merge-sort/",
		"content": "Cel\nMerge Sort (sortowanie przez scalanie) to stabilny algorytm sortowania, który gwarantuje stałą złożoność czasową O(nlog⁡n) niezależnie od początkowego układu danych. Wykorzystuje on paradygmat dziel i zwyciężaj.\nIdea działania\nAlgorytm opiera się na rekurencyjnym dzieleniu tablicy na coraz mniejsze fragmenty, aż osiągniemy pojedyncze elementy. Następnie wykonujemy proces scalania tych fragmentów w taki sposób, aby wynikowa struktura była posortowana.\nKluczowe kroki:\n\nPodział: Znajdujemy środek tablicy i dzielimy ją na dwie połowy.\nRekurencja: Wywołujemy Merge Sort dla lewej i prawej części.\nScalanie: Łączymy dwie posortowane podtablice w jedną większą, zachowując porządek.\n\nZłożoność czasowa w każdym przypadku (najlepszym, średnim i najgorszym):\nT(n)=2T(n/2)+n⟹O(nlog⁡n)Kiedy użyć?\nMerge Sort jest niezastąpiony, gdy wymagana jest stabilność (zachowanie kolejności elementów o tej samej wartości) oraz przewidywalny czas działania.\n\nZaleta: Gwarantowana wydajność O(nlog⁡n) nawet dla skrajnie niekorzystnych danych.\nWada: Wymaga O(n) dodatkowej pamięci na pomocniczą tablicę podczas scalania.\n\nTo podejście jest szczególnie efektywne przy sortowaniu struktur danych, które nie oferują swobodnego dostępu do elementów, takich jak listy jednokierunkowe.\nProces Scalania (Merge)\nTo najważniejszy etap algorytmu. Zakładamy, że mamy dwie posortowane podtablice i chcemy połączyć je w jedną.\nPrzebieg operacji:\n\nUstawiamy dwa wskaźniki na początku obu podtablic.\nPorównujemy elementy wskazywane przez wskaźniki.\nMniejszy z nich trafia do tablicy wynikowej, a odpowiadający mu wskaźnik przesuwa się o jedną pozycję.\nPowtarzamy czynność, aż jedna z podtablic zostanie opróżniona.\nPozostałe elementy z drugiej podtablicy kopiujemy bezpośrednio na koniec wyniku.\n\nDzięki temu, że wejściowe części są już posortowane, scalanie odbywa się w czasie liniowym O(n).\nImplementacja\nPoniżej znajduje się klasyczna implementacja wykorzystująca dodatkowy wektor pomocniczy.\nvoid merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {\nint n1 = mid - left + 1;\nint n2 = right - mid;\nvector&lt;int&gt; L(n1), R(n2);\n\nfor (int i = 0; i &lt; n1; i++) L[i] = arr[left + i];\nfor (int j = 0; j &lt; n2; j++) R[j] = arr[mid + 1 + j];\n\nint i = 0, j = 0, k = left;\nwhile (i &lt; n1 &amp;&amp; j &lt; n2) {\nif (L[i] &lt;= R[j]) {\narr[k] = L[i];\ni++;\n} else {\narr[k] = R[j];\nj++;\n}\nk++;\n}\nwhile (i &lt; n1) arr[k++] = L[i++];\nwhile (j &lt; n2) arr[k++] = R[j++];\n}\n\nvoid mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {\nif (left &lt; right) {\nint mid = left + (right - left) / 2;\nmergeSort(arr, left, mid);\nmergeSort(arr, mid + 1, right);\nmerge(arr, left, mid, right);\n}\n}",
		"tags": [ "note"]
},

{
		"title": "Quicksort",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/quicksort/",
		"content": "Cel\nQuicksort to jeden z najszybszych i najczęściej stosowanych algorytmów sortowania. Jego głównym celem jest uporządkowanie elementów tablicy w czasie średnim O(nlog⁡n) przy wykorzystaniu strategii „dziel i zwyciężaj”.\nIdea działania\nAlgorytm opiera się na wyborze tzw. pivotu (elementu osiowego). Wszystkie elementy mniejsze od pivotu trafiają na jego lewą stronę, a większe na prawą. Po takim podziale pivot znajduje się na swojej docelowej, ostatecznej pozycji. Proces ten powtarzamy rekurencyjnie dla powstałych podtablic.\nKluczowe kroki:\n\nWybór pivotu: Może to być pierwszy, ostatni, środkowy lub losowy element.\nPartycjonowanie: Przegrupowanie tablicy wokół pivotu.\nRekurencja: Sortowanie lewej i prawej części.\n\nWzór na złożoność czasową (przypadek średni):\nT(n)=2T(n/2)+Θ(n)⟹O(nlog⁡n)Partycjonowanie\n\nIstnieje wiele metod partycjonowania, które przeważnie są sobie równe pod względem wydajności.\n\nWykorzystujemy dwa wskaźniki, które przeszukują tablicę w jednym kierunku:\n\nWskaźnik wolny (i): Wyznacza granicę strefy elementów mniejszych. Wszystko na lewo od niego zostało już zweryfikowane jako mniejsze od pivotu.\nWskaźnik szybki (j): Przeszukuje kolejne komórki tablicy w poszukiwaniu wartości, które powinny trafić do lewej części.\n\nPrzebieg operacji:\n\nJeśli wskaźnik szybki napotka wartość mniejszą od pivotu, zwiększamy wskaźnik wolny i zamieniamy miejscami elementy pod tymi dwoma indeksami.\nJeśli wskaźnik szybki napotka wartość większą, po prostu przechodzi do następnej pozycji.\nPo sprawdzeniu wszystkich elementów, pivot zostaje zamieniony z elementem znajdującym się bezpośrednio za granicą strefy mniejszej.\n\nWażna uwaga: Elementy wewnątrz lewej i prawej części nie muszą być jeszcze posortowane względem siebie. Istotne jest jedynie to, że znajdują się po właściwej stronie elementu osiowego.\n\nKiedy użyć?\nQuicksort jest wyborem domyślnym w większości bibliotek standardowych np. std::sort w C++ często używa jego hybrydowej wersji.\n\nZaleta: Sortuje „w miejscu” (in-place), co oznacza bardzo małe zapotrzebowanie na dodatkową pamięć w porównaniu do Merge Sort.\nWada: W najgorszym przypadku (np. przy fatalnym doborze pivotu na już posortowanej tablicy) złożoność może spaść do O(n2).\n\nTo podejście jest niezastąpione, gdy zależy nam na szybkości procesora i efektywnym wykorzystaniu pamięci cache.\nWybór Pivotu\nStrategia wyboru pivotu ma kluczowe znaczenie dla wydajności. Najczęstsze techniki to:\n\nMedian-of-three: Wybieramy medianę z pierwszego, środkowego i ostatniego elementu.\nRandomizacja: Wybór losowego indeksu niemal całkowicie eliminuje ryzyko trafienia na przypadek O(n2).\n\nImplementacja\nint partition(vector&lt;int&gt;&amp; arr, int low, int high) {\nint pivot = arr[high]; // Wybieramy ostatni element jako pivot\nint i = low - 1;\n\nfor (int j = low; j &lt; high; j++) {\nif (arr[j] &lt; pivot) {\ni++;\nswap(arr[i], arr[j]);\n}\n}\nswap(arr[i + 1], arr[high]);\nreturn i + 1;\n}\n\nvoid quickSort(vector&lt;int&gt;&amp; arr, int low, int high) {\nif (low &lt; high) {\nint pi = partition(arr, low, high);\nquickSort(arr, low, pi - 1);\nquickSort(arr, pi + 1, high);\n}\n}",
		"tags": [ "note"]
},

{
		"title": "Sito Erastotenesa",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/sito-erastotenesa/",
		"content": "Cel\nWyznaczenie wszystkich liczb pierwszych mniejszych od danej\nIdea działania\nJeżeli wykreślimy wielokrotności wszystkich mniejszych liczb pierwszych, to mamy pewność, że następna niewykreślona liczba też jest pierwsza.\nZ przedziału [2,n] bierzemy liczbę najmniejszą (2), i wykreślamy wszystkie jesj wielokrotności.\nZ pozostałych wybieramy najmniejszą (3) i wykreślamy także jej wielokrotności.\nPowtarzamy to do momentu, gdy kolejna wybrana liczba i będzie większa niż n\nKiedy użyć?\nW przypadku tego algorytmu proste jest zauważenie potrzeby jego użycia, gdy taka jest obecna.\nImplementacja\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvector&lt;int&gt; sieve(int &amp; n) {\nif(n &lt; 2) return {};\nvector&lt;bool&gt; prime (n+1, true);\n\tprime[0] = false;\n\tprime[1] = false;\n\t\n\tfor(int i = 0; i*i &lt;= n; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j = i * i; t &lt;= n; t+= i){\n\t\t\t\tprime[t] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector&lt;int&gt; res;\n\tfor(int i = 2; i &lt; prime.size(); i++){\n\t\tif(prime[i]) res.push_back(i);\n\t}\n\treturn res;\n}\n\nZłożoność\nCzasowa: O(nlog⁡log⁡n)",
		"tags": ["include", "note"]
},

{
		"title": "Sortowanie bąbelkowe",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/sortowanie-babelkowe/",
		"content": "Cel\nPosortować <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">tablicę</a>.\nIdea działania\nIdziemy przez tablicę i jeżeli 2 kolejne elementy są w złej kolejności to je zamieniamy ze sobą. Przesuwamy iterator o 1 i sprawdzamy ponownie. Po 1 przejściu mamy gwarancje, że największy (lub najmniejszy element, zależy jak sortujemy) jest na końcu tablicy. Możemy iść od początku od nowa i powtarzać aż nie posortujemy całej tablicy.\nLista kroków\n\nUstaw zmienną i na 0. Będzie to nasz iterator.\nPorównaj tab[i] i tab[i+1], jeżeli są w złej kolejności zamień je.\nZwiększ i o 1.\nPowtarzaj kroki 2 i 3 aż tab[i+1] nie wyjdzie poza tablice\nPowtarzaj kroki 1-4 aż cała tablica nie będzie posortowana (tab.size() - 1 razy) Za każdym razem możesz skrócić zakres iteratora i o 1, ponieważ końcowe elementu powinny już być posortowane.\n\nZłożoność\nCzasowa: O(n2)\nPamięciowa: O(1)\nKiedy użyć\nPrawie nigdy, to jest mało efektywny algorytm sortowania. Najczęściej używamy funkcji sort(). Jeżeli już musimy sami coś zaimplementować, to lepiej zrobić <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">Merge Sort</a>.\nKod\nvoid bubbleSort(vector&lt;int&gt; &amp; tab){\n\tfor(int k = 0; k &lt; tab.size() - 1; k++){\n\t\tbool changed = false; // Optymalizacja: sprawdzamy, czy tablica została już posortowana\n\t\tfor(int i = 0; i &lt; tab.size() - k - 1; i++){\n\t\t\tif(tab[i] &gt; tab[i + 1]){\n\t\t\t\tswap(tab[i], tab[i + 1]);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\t\tif(!changed) break;\n\t}\n}",
		"tags": [ "note"]
},

{
		"title": "Test pierwszości",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/test-pierwszosci/",
		"content": "Cel\nSprawdzenie czy liczba jest pierwsza\nIdea działania\nLiczba jest pierwsza jeżeli jej dzielnikami są tylko 1 i ona sama. Możemy sprawdzić wszystkie liczby w przedziale [2,n]. Jest to metoda naiwna.\nZamiast tego możemy wygenerować liczby pierwsze za pomocą <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/algorytmy/sito-erastotenesa/\">sita Eratostenesa</a> i sprawdzić tylko je.\nZaczniemy od generowania liczb pierwszych w przedziale [0,nmax]. Potem aby sprawdzić czy dana liczba jest pierwsza przejdziemy przez liczby pierwsze po kolei i sprawdzimy czy zachodzi podzielność.\nKiedy użyć?\nJeżeli mamy mało liczb, ale mogą być duże (np. 1014), to lepiej użyć metody naiwnej.\nJeżeli mamy dużo, ale stosunkowo małych liczb, to lepiej użyć sita.\nImplementacja\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nbool isPrime(vector&lt;int&gt; &amp;primes, int&amp; n){\n\tfor(auto&amp; p: primes){\n\t\tif(p * p &gt; n) break;\n\t\t\n\t\tif(n % p == 0) return false;\n\t}\n\treturn true;\n}\n\nZłożoność\nCzasowa: O(nln⁡n) (Jeżeli mamy listę liczb pierwszych)\nPamięciowa: O(nmax",
		"tags": ["include", "note"]
},

{
		"title": "Wyszukiwanie binarne",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/algorytmy/wyszukiwanie-binarne/",
		"content": "​Idea działania\n​Algorytm działa na zasadzie dziel i zwyciężaj. Zamiast sprawdzać każdy element po kolei (co zajęłoby dużo czasu w dużych zbiorach), algorytm celuje w środek zakresu i decyduje, w którą stronę iść dalej.\n​Wymaganie wstępne: Tablica musi być posortowana (rosnąco lub malejąco).\n​Algorytm krok po kroku:\n\n​Definiujemy początek (left) i koniec (right) przeszukiwanego zakresu.\n​Wyznaczamy środek (mid).\n​Porównujemy element środkowy z szukaną wartością:\n\n​Jeżeli tablica[mid]==szukana: Znaleźliśmy element. Zwracamy indeks.\n​Jeżeli tablica[mid]&gt;szukana: Element musi być &quot;na lewo&quot;. Przesuwamy koniec zakresu (right=mid−1).\n​Jeżeli tablica[mid]&lt;szukana: Element musi być &quot;na prawo&quot;. Przesuwamy początek zakresu (left=mid+1).\n\n​Powtarzamy proces dopóki left nie minie się z right.\n\n​Dlaczego jest to &quot;efektywne&quot;? (Złożoność)\n​Różnica wydajności jest ogromna dla dużych danych.\nZłożoność czasowa:\nO(log2⁡n)",
		"tags": [ "note"]
},

{
		"title": "Drzewo Przedziałowe",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/drzewo-przedzialowe/",
		"content": "Cel i motywacja\nDrzewo przedziałowe to jedna z najbardziej wszechstronnych struktur w informatyce, służąca do efektywnego zarządzania danymi rozłożonymi na liniowej osi. Rozwiązuje ono fundamentalny problem: jak pogodzić częste aktualizacje danych z częstymi zapytaniami o wyniki operacji na ich podzbiorach.\nW przypadku zwykłej tablicy mamy do czynienia z kompromisem:\n\nAktualizacja punktowa: O(1).\nZapytanie o przedział: wymaga przejścia pętlą przez elementy, co zajmuje O(n).\n\nDrzewo przedziałowe dzięki swojej hierarchicznej budowie sprowadza obie te operacje do złożoności logarytmicznej O(log⁡n).\nStruktura i budowa\nDrzewo przedziałowe jest pełnym drzewem binarnym. Każdy jego poziom reprezentuje coraz większe rozdrobnienie danych:\n\nKorzeń: Reprezentuje cały zakres tablicy, od indeksu 0 do n−1.\nWęzły wewnętrzne: Każdy taki węzeł dzieli zakres swojego rodzica na dwie, niemal równe części. Jeśli rodzic obsługuje zakres [L,R], to jego lewe dziecko obsłuży [L,mid], a prawe [mid+1,R], gdzie mid=(L+R)/2.\nLiście: To najniższy poziom drzewa. Każdy liść odpowiada dokładnie jednemu elementowi oryginalnej tablicy.\n\nIle pamięci potrzeba?\nDla tablicy o rozmiarze n, która nie jest potęgą liczby 2, drzewo może posiadać puste węzły na ostatnim poziomie. Standardowo przyjmuje się bezpieczny rozmiar tablicy drzewa jako 4n. Pozwala to uniknąć wyjścia poza zakres przy implementacji opartej na tablicy.\nPodstawowe warianty drzew\nW zależności od tego, jaką funkcję agregującą przechowujemy w węzłach, drzewo zmienia swoje przeznaczenie.\n1. Drzewo typu SUM (Suma na przedziale)\nW każdym węźle przechowujemy sumę wartości jego dzieci.\n\nZastosowanie: Obliczanie sumy elementów w zakresie [L,R].\nWęzeł rodzica: tree[v] = tree[2*v] + tree[2*v+1].\nNeutralny element: Dla operacji sumowania elementem neutralnym jest 0 (zwracane, gdy zapytanie nie pokrywa się z zakresem węzła).\n\n2. Drzewo typu MIN (Minimum na przedziale)\nW każdym węźle przechowujemy najmniejszą wartość znalezioną w jego poddrzewie.\n\nZastosowanie: Rozwiązywanie problemu RMQ (Range Minimum Query). Pozwala błyskawicznie sprawdzić, jaka jest najmniejsza wartość na danym odcinku.\nWęzeł rodzica: tree[v] = min(tree[2*v], tree[2*v+1]).\nNeutralny element: Nieskończoność (infinity), ponieważ każda inna liczba będzie od niej mniejsza.\n\n3. Drzewo typu MAX (Maksimum na przedziale)\nDziała analogicznie do drzewa typu MIN, ale przechowuje wartości największe.\n\nZastosowanie: Szukanie najwyższego punktu, największego zysku lub limitów w danym zakresie.\nWęzeł rodzica: tree[v] = max(tree[2*v], tree[2*v+1]).\nNeutralny element: Minus nieskończoność lub 0 (jeśli operujemy tylko na liczbach dodatnich).\n\nOperacje podstawowe krok po kroku\nBudowa (Build)\nProces budowy zaczynamy od liści (wartości tablicy) i idziemy w górę. Jest to proces rekurencyjny. Najpierw budujemy lewe poddrzewo, potem prawe, a na końcu obliczamy wartość dla bieżącego węzła na podstawie wyników jego dzieci. Złożoność wynosi O(n).\nvoid build(vector&lt;int&gt; arr, int v, int tl, int tr) {\nif (tl == tr) {\n// Dotarliśmy do liścia\ntree[v] = arr[tl];\n} else {\nint tm = (tl + tr) / 2;\n// Budujemy lewe i prawe poddrzewo\nbuild(arr, 2 * v, tl, tm);\nbuild(arr, 2 * v + 1, tm + 1, tr);\n\n// Sumujemy wartości dzieci (dla MIN użyj: min, dla MAX: max)\ntree[v] = tree[2 * v] + tree[2 * v + 1];\n}\n}\n\nAktualizacja punktowa (Update)\nKiedy zmienia się wartość arr[i], musimy:\n\nZnaleźć liść odpowiadający indeksowi i.\n\nZmienić jego wartość.\n\nCofnąć się wzdłuż ścieżki do korzenia i przeliczyć wartości we wszystkich węzłach znajdujących się nad tym liściem.\nPonieważ wysokość drzewa to log⁡n, wykonujemy tylko tyle operacji przeliczenia.\n\n// arr - tablica wejściowa, tree - tablica drzewa\n// v - aktualny węzeł, tl/tr - lewy i prawy brzeg zakresu węzła\nvoid build(int arr[], int v, int tl, int tr) {\nif (tl == tr) {\ntree[v] = arr[tl];\n} else {\nint tm = (tl + tr) / 2;\nbuild(arr, 2 * v, tl, tm);\nbuild(arr, 2 * v + 1, tm + 1, tr);\n\ntree[v] = tree[2 * v] + tree[2 * v + 1];\n}\n}\n\nZapytanie o przedział (Query)\nTo najbardziej wyrafinowana część. Zapytanie o zakres [L,R] może trafić na węzeł, który:\n\nCałkowicie mieści się w [L,R]: Zwracamy gotową wartość z tego węzła.\nCałkowicie leży poza [L,R]: Zwracamy element neutralny (np. 0 lub nieskończoność).\nCzęściowo nachodzi na [L,R]: Dzielimy zapytanie i wysyłamy je do obojga dzieci, a następnie łączymy wyniki.\n\nNawet jeśli przedział jest bardzo szeroki, zostanie on rozbity na najwyżej 2⋅log⁡n węzłów.\n// l, r - zakres zapytania użytkownika\nint query(int v, int tl, int tr, int l, int r) {\nif (l &gt; r) {\nreturn 0; //Element neutralny\n}\nif (l == tl &amp;&amp; r == tr) {\nreturn tree[v];\n}\nint tm = (tl + tr) / 2;\n\nreturn query(2 * v, tl, tm, l, min(r, tm))\n+ query(2 * v + 1, tm + 1, tr, max(l, tm + 1), r);\n}\n\nDalsze sposoby użycia drzew przedziałowych\nTo, co zostało omówione powyżej to dopiero wierzchołek góry lodowej, jeżeli chodzi o drzewa przedziałowe. [TODO]",
		"tags": [ "note"]
},

{
		"title": "Kolejka",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/kolejka/",
		"content": "Cel\nKolejka (ang. queue) to liniowa struktura danych działająca według zasady FIFO (First In, First Out). Oznacza to, że pierwszy element, który został dodany do kolekcji, będzie pierwszym, który ją opuści. Jest to dokładne przeciwieństwo stosu.\nIdea działania\nDziałanie kolejki można porównać do ogonika w sklepie – osoba, która przyszła jako pierwsza, jest obsługiwana jako pierwsza, a nowe osoby dołączają zawsze na samym końcu. Operacje odbywają się na dwóch różnych końcach: dodajemy z tyłu (ang. back), a usuwamy z przodu (ang. front).\nPodstawowe operacje:\n\nPush / Enqueue: Wstawienie elementu na koniec kolejki.\nPop / Dequeue: Usunięcie elementu z początku kolejki.\nFront: Podgląd wartości elementu znajdującego się na początku.\nIsEmpty: Sprawdzenie, czy kolejka jest pusta.\n\nZłożoność czasowa dla wszystkich powyższych operacji wynosi O(1).\nW c++\nW c++ możemy użyć struktury danych queue&lt;type&gt;",
		"tags": [ "note"]
},

{
		"title": "Mnożenie",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/omowienia-zadan/mnozenie/",
		"content": "Cel\nStandardowe typy danych (jak int czy long long) mają swoje limity pamięciowe. Gdy musimy pomnożyć przez siebie liczby mające setki lub tysiące cyfr, musimy zrezygnować z gotowych rozwiązań i zaimplementować własną logikę mnożenia, opartą na metodzie, którą znamy ze szkoły – mnożeniu pisemnym.\nOmówienie algorytmu\n1. Przygotowanie danych\nLiczby wczytujemy jako ciągi znaków (String), co pozwala na ich dowolną długość. Następnie konwertujemy je na tablice liczb, przechowujące poszczególne cyfry.\n\nObsługa znaku: Należy sprawdzić, czy liczby są ujemne. Wynik będzie ujemny tylko wtedy, gdy dokładnie jedna z liczb posiada minus.\nOdwrócenie kolejności: Tablice cyfr warto odwrócić tak, aby cyfra jedności znalazła się pod indeksem 0. To znacznie ułatwia zarządzanie indeksami podczas mnożenia i przenoszenia nadwyżek.\n\n2. Tablica wynikowa\nRozmiar tablicy wynikowej c powinien wynosić maksymalnie a.size()+b.size().\n\nUwaga: Suma liczby cyfr dwóch mnożonych liczb określa maksymalną długość wyniku.\n\n3. Logika mnożenia (Splot)\nW przeciwieństwie do zwykłego mnożenia pisemnego, gdzie mnożymy liczbę a przez każdą cyfrę b, tu będziemy mnożyć każdą cyfrę a przez każdą cyfrę b.\nZamiast przejmować się skomplikowanymi przeniesieniami, pozwolimy zapisać dowolną liczbę na miejscu cyfry. W [[#4. Normalizacja wyniku (Obsługa przeniesień)]] się zajmiemy tego konsekwencjami.\nUżywając dwóch zagnieżdżonych pętli, mnożymy każdą cyfrę pierwszej liczby przez każdą cyfrę drugiej. Wynik mnożenia pary cyfr na pozycjach i oraz j dodajemy do tablicy wynikowej pod indeksem i+j.\nZależność tę opisuje wzór:\nc[i+j]+=a[i]⋅b[j]4. Normalizacja wyniku (Obsługa przeniesień)\nPo zakończeniu mnożenia wszystkich par, w polach tablicy c mogą znajdować się liczby znacznie większe niż 10. Musimy &quot;uporządkować&quot; tablicę, idąc od początku:\n\nWartość pod danym indeksem zostaje zastąpiona przez resztę z dzielenia przez 10.\nNadwyżka (część całkowita z dzielenia) przechodzi do kolejnego pola.\n\n5. Formatowanie wyjścia\nZanim wyświetlimy wynik, musimy wykonać dwa kroki:\n\nUsunięcie zer wiodących: Podczas mnożenia (np. 0⋅0) na końcu tablicy wynikowej mogą pojawić się niepotrzebne zera (np. otrzymamy 500 zamiast 5). Należy je pominąć, aż trafimy na pierwszą cyfrę znaczącą.\nZnak: Jeśli z analizy na początku wynika, że liczba jest ujemna (a wynik nie jest zerem), wypisujemy znak -.\nKolejność: Ponieważ operowaliśmy na odwróconych tablicach, wynik wypisujemy od końca.",
		"tags": [ "note"]
},

{
		"title": "Podtablica o największej sumie",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/omowienia-zadan/podtablica-o-najwiekszej-sumie/",
		"content": "Cel\nZnaleźć największą sumę <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/podtablica/\">podtablicy</a> w danej <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">tablicy</a>.\nMetoda naiwna\nMożemy przejść przez każdą możliwą podtablicę i iterując się przez jej elementy, obliczyć jej sumę.\nZłożoność czasowa: O(n3)\nZłożoność pamięciowa: O(1)\nLepsza metoda naiwna\nJeżeli znamy sumę elementów [j,i] to możemy prosto obliczyć sumę [j,i+1], trzeba dodać wartość elementu i+1.\nZłożoność czasowa: O(n2)\nZłożoność pamięciowa: O(1)\nMetoda z użyciem <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/szkola/informatyka/techniki/suma-prefiksowa/\">sum prefiksowych</a>\nWiemy że:\nSuma(i,j)=P[j+1]−P[i]Zauważmy, że aby suma były największa dla danego j, trzeba odjąć jak najmniejsze P[i]. Możemy zapamiętać, jaki był najmniejszy element do tej pory i go odjąć. To eliminuje złożoność kwadratową z naszego programu.\nZłożoność czasowa: O(n)\nZłożoność pamięciowa: O(n)\nKod\nint maxSubArray(vector&lt;int&gt; &amp; a){\n\tvector&lt;int&gt; prefix(a.size() + 1, 0);\n\t\n\t//Budujemy tablicę z sumami prefiksowymi\n\tfor(int i = 0; i &lt; a.size(); ++i){\n\t\tprefix[i + 1] = prefix[i] + a[i];\n\t}\n\tint res = INT_MIN; // Początkowo ustawiamy sumę na najmniejszą możliwą\n\tint minPrefix = 0;\n\tfor(int j = 0; j &lt; a.size(); j++){\n\t\tres = max(res, a[j] - minPrefix);\n\t\tminPrefix = min(minPrefix, a[j]);\n\t}\n\treturn res;\n}\n\nNajlepsza metoda\nZauważmy, że nigdy nie opłaca nam się zacząć podtablicy od fragmentu z sumą ujemną.\nJeżeli napotkamy taki fragment, to lepiej od nowa zacząć liczyć tablicę, ponieważ zero jest większe niż jakakolwiek liczba ujemna (przeważnie).\nKorzystając z tej zasady możemy znaleźć bardzo prostą metodę szukania takiej tablicy. Idziemy przez tablicę licząc teraźniejszą sumę i jeżeli jest mniejsza od 0, to ją ustawiamy na 0. W międzyczasie aktualizujemy największą sumę jaką spotkaliśmy.\nDlaczego to działa?\nSzukamy najlepszego „początku” dla każdego końca. Dla elementu na pozycji i, najlepszym początkiem jest albo on sam (jeśli to, co było wcześniej, dawało sumę ujemną), albo dołączenie do poprzedniej najlepszej grupy (jeśli ta była dodatnia).\nZłożoność czasowa: O(n)\nZłożoność pamięciowa: O(1)\nKod\nint maxSubArray(vector&lt;int&gt;&amp; nums) {\n\tint total = 0;\n\tint res = nums[0];\n\tfor(int i = 0; i &lt; nums.size(); i++){\n\t\ttotal += nums[i];\n\t\tres = max(res, total);\n\t\t\n\t\ttotal = max(total, 0); //Jeżeli suma jest ujemna, to ją pomijamy\n\t}\n\treturn res;\n}",
		"tags": [ "note"]
},

{
		"title": "Podtablica",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/podtablica/",
		"content": "To ciągły fragment <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">tablicy</a>. Inaczej to ujmując, podtablica to <a class=\"internal-link is-unresolved\" href=\"/404\" target=\"\">Tablica</a> w tablicy. Może obejmować całą oryginalną tablicę.\nIlość\nJeżeli mamy tablicę rozmiaru N, to mamy:\nn(n+1)2niepustych podtablic.",
		"tags": [ "note"]
},

{
		"title": "Stos",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/stos/",
		"content": "Cel\nStos (ang. stack) to liniowa struktura danych działająca według zasady LIFO (Last In, First Out). Oznacza to, że ostatni element, który został dodany do kolekcji, jest pierwszym, który ją opuszcza.\nIdea działania\nDziałanie stosu można porównać do wieży ułożonej z talerzy – aby zdjąć ten, który znajduje się na spodzie, musimy najpierw usunąć wszystkie leżące nad nim. Wszystkie operacje (dodawanie i usuwanie) odbywają się wyłącznie na jednym końcu, nazywanym wierzchołkiem (ang. top).\nPodstawowe operacje :\n\nPush: Wstawienie elementu na wierzchołek stosu.\nPop: Usunięcie elementu z wierzchołka.\nTop/Peek: Podgląd wartości elementu na wierzchołku bez jego usuwania.\nIsEmpty: Sprawdzenie, czy stos zawiera jakiekolwiek dane.\n\nZłożoność czasowa dla wszystkich powyższych operacji wynosi O(1).\nW c++\nW c++ możemy użyć struktury danych stack&lt;type&gt;",
		"tags": [ "note"]
},

{
		"title": "Rekurencja",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/techniki/rekurencja/",
		"content": "Funkcja rekurencyjna to taka, która woła samą siebie pośrednio lub bezpośrednio.\nAlgorytm rekurencyjny za każdym wywołaniem funkcji powinien znajdować się o krok bliżej do wyniku.\nPrzypadek bazowy\nPonieważ funkcja może wołać się w nieskończoność, konieczne jest ustanowienie sytuacji bazowej (np. Jeżeli a == 1 to zwróć 1).\nArgumenty\nZa każdym razem, gdy wywołujemy funkcję rekurencyjnie, musimy zmodyfikować jej argumenty. W przeciwnym razie funkcja będzie przetwarzać te same dane w kółko, co doprowadzi do tzw. przepełnienia stosu (stack overflow). Zazwyczaj dążymy do tego, aby argument przybliżał nas do przypadku bazowego (np. zmniejszamy liczbę n o 1 lub dzielimy zbiór danych na pół).\nJak zaimplementować?\n\nZdefiniuj przypadek bazowy: To taki, gdzie wynik funkcji jest trywialny i nie wymaga dalszych wywołań.\nZdefiniuj przypadek rekurencyjny: Podziel problem na mniejsze podproblemy i rozwiąż je oddzielnie, wołając tę samą funkcję.\nUpewnij się, że funkcja ma koniec: Funkcja musi zawsze trafić na jakiś przypadek bazowy. Wartość przekazywana niższemu pokoleniu funkcji powinna być mniejsza lub prostsza.\nPołącz wyniki funkcji po ich zawołaniu: Zsumuj, pomnóż lub zestaw ze sobą rezultaty otrzymane z głębszych poziomów rekurencji.\n\nKiedy używać\nRekurencji często używa się przy pracy z drzewami i grafami. Jeżeli jakiś program ma złożoność wykładniczą, to prawdopodobnie używa rekurencji.\nRekurencja jest przydatna, gdy w danej sytuacji musimy się „rozdzielić” na kilka przypadków. Silniki szachowe opierają się na rekurencji, ponieważ różne ruchy można przedstawić w formie drzewa. Warto jednak pamiętać o memoizacji (zapamiętywaniu wyników), aby nie obliczać tego samego kilka razy.\nPrzykłady\n1. Silnia (klasyka gatunku)\nSilnia z liczby n (zapisywana jako n!) to iloczyn wszystkich liczb naturalnych od 1 do n.\n\nPrzypadek bazowy: 0!=1.\nKrok rekurencyjny: n!=n⋅(n−1)!.\n\n2. Ciąg Fibonacciego\nKażda liczba w ciągu jest sumą dwóch poprzednich. To idealny przykład na to, jak funkcja „rozgałęzia się” na dwa kolejne wywołania.\n\nPrzypadek bazowy: Dla n=0 zwróć 0, dla n=1 zwróć 1.\nKrok rekurencyjny: F(n)=F(n−1)+F(n−2).",
		"tags": [ "note"]
},

{
		"title": "Suma prefiksowa",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/techniki/suma-prefiksowa/",
		"content": "Cel\nTechnika ta pozwala na błyskawiczne (w czasie stałym) obliczanie sumy dowolnego spójnego fragmentu tablicy.\nIdea działania\nPolega na przygotowaniu dodatkowej tablicy P, w której pod indeksem i przechowujemy sumę wszystkich elementów oryginalnej tablicy od początku aż do pozycji i−1. Dzięki temu suma dowolnego przedziału staje się różnicą dwóch wartości.\nWzór na element tablicy prefiksowej:\nP[i]=∑k=0i−1arr[k]Przyjmujemy, że P[0]=0.\nKiedy użyć?\nGłównym zastosowaniem jest obliczanie sum na przedziałach [L,R]. Zamiast każdorazowo sumować elementy pętlą (co zajmuje czas O(n)), korzystamy z gotowych wyników:\nSuma(L,R)=P[R+1]−P[L]Gdzie:\n\nL: indeks początku przedziału,\nR: indeks końca przedziału,\nP: pomocnicza tablica sum prefiksowych.\n\nTo podejście jest niezastąpione w zadaniach optymalizacyjnych, gdzie musimy wielokrotnie pytać o sumy różnych podtablic.\n\nSumy Postfiksowe\nMożemy również stworzyć tablicę sum od końca (od prawej do lewej). Jest to przydatne, gdy potrzebujemy informacji o &quot;reszcie&quot; tablicy z prawej strony.\nPost[i]=∑k=in−1arr[k]Implementacja (C++)\nBudowa tablicy prefiksowej zajmuje czas O(n) i wymaga O(n) dodatkowej pamięci.\n// Zakładamy, że n to rozmiar tablicy arr\nvector&lt;int&gt; prefixSum(n + 1, 0);\n\nfor(int i = 0; i &lt; n; i++) {\nprefixSum[i + 1] = prefixSum[i] + arr[i];\n}\n\nZadania do poćwiczenia\nTechnika ta pojawia się w ogromnej liczbie problemów. Warto zacząć od:\n\nLeetCode: Zbiór zadań Prefix Sum\nUSACO Guide: Srebrny poziom - Sumy prefiksowe - zadania",
		"tags": [ "note"]
},

{
		"title": "Zadania",
		"date":"Mon Feb 23 2026 16:08:22 GMT+0000 (Coordinated Universal Time)",
		"url":"/szkola/informatyka/zadania/zadania/",
		"content": "Zadanie4ŹródłoPoziomTematyNearest Smaller ValuesCSESProste#stosTasks and DeadlinesCSESProste#greedySocial DistancingUSACOŚrednie#binSearchKompatybilne ParyOIJTrudne#bitmask",
		"tags": ["stos", "greedy", "binSearch", "bitmask", "note"]
}
]